* 选择排序  
    * 选择排序，由小到大输出：每次都是从底最后一个，跟其上面的所有数据做比较，每次比较过程中，用minIndex来记录这一轮最小数的下标，待结束后放在较小的存在0号位置。
    * 注意的就是不要没一个比较的时候直接交换，只记录下标，等到内层循环结束之后再做交换
    * 总共比较的次数是一定的：(n-1)+(n-2)+...+1 = (n-1)*n/2 = 1/2*n² - 1/2*n，那么时间复杂度为O(n²)

* 冒泡排序  
    * 冒泡排序，每次比较都是从0号元素开始，一次比较0-1,1-2,2-3...，一次循环结束，最大的元素放在n-1号最大的位置。
    * 下一次比较也是从0号元素开始，只是最大的元素已经在n-1位置，那么n-1位置不需要参与循环比较
    * 相比与普通的冒泡排序，可以减少比较的次数： 如果在一次冒泡过程中，一次交换都没有执行，那么整个数组就已经是排序的状态了
    * 总共比较的次数是不定的：最多是(n-1)+(n-2)+...+1 = (n-1)*n/2 = 1/2*n² - 1/2*n，那么最大的时间复杂度为O(n²)；最少是n-1次，最小的时间复杂度是O(n)
    
* 插入排序
    * 插入排序：让元素i之前的元素都保持由小到大排序，每次比较都是跟当前元素之前的所有元素进行比较。好比从牌堆里面摸牌，摸出来的牌每次都要从手上的牌从后往前理一遍。
    * 思路是从下标1元素开始，跟之前的所有元素比较，如果当前元素比前一个元素小，那么就进行交换。这样，每一轮下来，位置i的元素会被安排到合适的位置。
    * tips：如果当前比对的元素，比之前的一个元素要大，那么就可以不继续了，因为前前一个元素一定是比前一个元素小的
    * 图形化的演示http://cmsblogs.com/?p=4688    
    * 总共比较的次数是不定的：最多是(n-1)+(n-2)+...+1 = (n-1)*n/2 = 1/2*n² - 1/2*n，那么最大的时间复杂度为O(n²)；最少是n-1次，最小的时间复杂度是O(n)

* 归并排序
    * [left ~ middle]和[middle+1, right]进行merge，并保持left ~ right之间由小到大排序
    * 新建一个长度为right-left+1长度的数组newArray
    * 设2个指针pLeft和pRight，初始pLeft=left，pRight=middle+1。每次找到pLeft和pRight中较小的一个，放入到newArray中，放入newArray用下标targetIndex
    * 待pLeft=middle&&pRight=right，表明merge结束，此时需要将newArray中的数据拷贝到origin中的left ~ right下标段处。

